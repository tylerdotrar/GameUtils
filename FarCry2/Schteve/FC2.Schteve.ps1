function Schteve {
#.SYNOPSIS
# PowerShell based automation for Far Cry 2 modding.
# ARBITRARY VERSION NUMBER:  2.5.3
# AUTHOR:  Tyler McCann (@tylerdotrar)
#
#.DESCRIPTION
# I couldn't think of a catchy name for this tool, so now we're stuck with SCHTEVE.  This 
# script is meant to automate some of the tedious aspects of modding Ubisoft's Far Cry® 2. 
# Using a handful of different open source mod tools (e.g., Gibbed.Dunia, xbt2dds, etc.), 
# this tool automates many of the most common modding tasks:
#
#
#     [start]    Launches 'FarCry2.exe' for quicker testing.
#
#     [unpack]   Recursively unpacks all '.dat' files located in Far Cry 2's '\Data_Win32'
#                folder.  Once unpacked, it then converts the '.rml' files into 
#                human-readable '.xml' files and unpacks the 'entitylibrary.fcb' and
#                'entitylibrarypatchoverride.fcb' archives.  Lastly, it moves all of the 
#                unpacked and converted content to the Sandbox's '\[] Raw Files' directory.
#
#     [pack]     Re-packs the '\patch_unpack' folder in the Sandbox and moves the outputed 
#                'patch.dat' and 'patch.fat' files back into Far Cry 2's '\Data_Win32'
#                directory, all while leaving '\patch_unpack' available for more modding.
#      
#     [convert]  Converts '.xbt' texture files to and from '.dds'/'.schteve' files for
#                quicker and easier texture editing.
#
#     [decode]   Decodes the internal '.xml' files usually found in the folders of 
#                unpacked 'entitylibrarypatchoverride.fcb' files.
#
#
# Notes:
# - Supports both standard PowerShell and PowerShell Core.
# - Don't modify directory/file names generated by SCHTEVE or in the 'Tools' directory.
# - The 'exit' command will quit Schteve even within [options] and [convert].
# - The 'back' command works while inputing individual directories within [modify].
#
#
# Troubleshooting:
#   If you can't run this script, verify that your Execution Policy is set to
#   'Unrestricted'.  By default, Execution Policy in PowerShell is set to 'Restricted' 
#   meaning scripts can't be run.  Executing the follwing command will allow the 
#   currently logged on user (you) to run scripts:
#   Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Unrestricted
#
#.LINK
# https://github.com/tylerdotrar/FarCry2-Schteve
# https://nexusmods.com/farcry2/mods/316
    

    # Window Modification
    $OriginalWindow                = $Host.UI.RawUI.WindowTitle
    $OriginalColor                 = $Host.UI.RawUI.BackgroundColor
    $Host.UI.RawUI.WindowTitle     = "SCHTEVE ── FarCry2 Modding Utility (v2.5.3)"
    $Host.UI.RawUI.BackgroundColor = "Black"


    ### Base Directories ###
    $script:FarCry2Folder <#RegexTag1#> = "C:\Example\Far Cry 2"
    $script:SandboxFolder <#RegexTag2#> = "C:\Example\Far Cry 2\Modding\Sandbox"
    $script:ToolsFolder   <#RegexTag3#> = "C:\Example\Far Cry 2\Modding\Tools"


    ### Derivative Paths ###

    # Derivs 1
    $script:FarCry2exe     = "$script:FarCry2Folder\bin\FarCry2.exe"
    $script:FarCry2Win32   = "$script:FarCry2Folder\Data_Win32"

    # Derivs 2
    $script:UnpackOutput   = "$script:SandboxFolder\[] Raw Files"
    $script:XbtTextures    = "$script:SandboxFolder\[] Texture Conversion\XBT"
    $script:DdsTextures    = "$script:SandboxFolder\[] Texture Conversion\DDS"
    $script:XmlDecoding    = "$script:SandboxFolder\[] XML Decoding"
    $script:PatchUnpack    = "$script:SandboxFolder\patch_unpack"

    # Derivs 3
    $script:PackExe        = "$script:ToolsFolder\Gibbed.Dunia\Gibbed.Dunia.Pack.exe"
    $script:UnpackExe      = "$script:ToolsFolder\Gibbed.Dunia\Gibbed.Dunia.Unpack.exe"
    $script:XmlExe         = "$script:ToolsFolder\Gibbed.Dunia\Gibbed.Dunia.ConvertXml.exe"
    $script:BinaryExe      = "$script:ToolsFolder\Gibbed.Dunia\Gibbed.Dunia.ConvertBinary.exe"
    $script:ConverterExe   = "$script:ToolsFolder\Texture Converter\FC2.xbt2dds.exe"
    $script:DecoderExe     = "$script:ToolsFolder\XML Decoder System Files\Wob.FC2Dunia.exe"


    # Boolean Arrays Used for Directory Validation
    $script:InvalidDerivs1 = @($FALSE, $FALSE)
    $script:InvalidDerivs2 = @($FALSE, $FALSE, $FALSE, $FALSE, $FALSE)
    $script:InvalidDerivs3 = @($FALSE, $FALSE, $FALSE, $FALSE, $FALSE, $FALSE)


    # Header, Directory Listings, Path Validation, and Menu Listings
    function Banner ([switch]$FunctionCheck) {
        
        function Verify-BaseFolders   ([string]$BaseItem) {

            if (Test-Path -LiteralPath $BaseItem) { return $FALSE }
            else { return $TRUE }
        }
        function Verify-Derivatives   ([array]$DerivArray,[array]$BooleanArray) {

            for ($Index = 0; $Index -lt $DerivArray.Count; $Index++) {
                
                $DerivativeItem = ($DerivArray[$Index])

                if (Test-Path -LiteralPath $DerivativeItem) { $BooleanArray[$Index] = $FALSE }
                else { $BooleanArray[$Index] = $TRUE }
            }

            return $BooleanArray
        }
        function Display-Derivatives  ([string]$BaseItem,[array]$DerivArray) {

            for ($Index = 0; $Index -lt $DerivArray.Count; $Index++) {
                
                $DerivativeItem = ($DerivArray[$Index])
                $RelativePath = $DerivativeItem.Replace($BaseItem,'.')

                Write-Host "`t`t     - " -NoNewline -ForegroundColor Yellow

                if (Test-Path -LiteralPath $DerivativeItem) { Write-Host $RelativePath }
                else { Write-Host $RelativePath -ForegroundColor Red }
            }
            Write-Host ""
        }


        Write-Host "
    ──╔═══╗╔═══╗╔╗ ╔╦════╦═══╦╗  ╔╦═══╗──    
   ───║╔═╗║║╔═╗║║║ ║║╔╗╔╗║╔══╣╚╗╔╝║╔══╝───   
  ────║╚══╗║║ ╚╝║╚═╝╠╝║║╚╣╚══╬╗║║╔╣╚══╗────  
  ────╚══╗║║║ ╔╗║╔═╗║ ║║ ║╔══╝║╚╝║║╔══╝────  
   ───║╚═╝╠╣╚═╝╠╣║ ║╠╗║║╔╣╚══╦╬╗╔╬╣╚══╦╗──   
    ──╚═══╩╩═══╩╩╝ ╚╩╝╚╝╚╩═══╩╝╚╝╚╩═══╩╝─    " -ForegroundColor Yellow

        Write-Host " ───────────────────────────────────────────" -ForegroundColor Yellow
        Write-Host "  SC" -NoNewline -ForegroundColor Red
        Write-Host "ripted " -NoNewline
        Write-Host "H" -NoNewline -ForegroundColor Red
        Write-Host "elper " -NoNewline
        Write-Host "T" -NoNewline -ForegroundColor Red
        Write-Host "ool for (FC2) D" -NoNewLine
        Write-Host "EVE" -NoNewline -ForegroundColor Red
        Write-Host "lopers  "
        Write-Host " ───────────────────────────────────────────" -ForegroundColor Yellow


        # Verify Existence of Base Folders
        $InvalidDirectory1     = Verify-BaseFolders -BaseItem $script:FarCry2Folder
        $InvalidDirectory2     = Verify-BaseFolders -BaseItem $script:SandboxFolder
        $InvalidDirectory3     = Verify-BaseFolders -BaseItem $script:ToolsFolder

        $DerivativeArray1      = @($script:FarCry2exe, $script:FarCry2Win32)
        $DerivativeArray2      = @($script:UnpackOutput, $script:XbtTextures, $script:DdsTextures, $script:XmlDecoding, $script:PatchUnpack)
        $DerivativeArray3      = @($script:PackExe, $script:UnpackExe, $script:BinaryExe, $script:XmlExe, $script:DecoderExe, $script:ConverterExe)

        # Verify Existence of Derivative Folders / Files
        $script:InvalidDerivs1 = Verify-Derivatives -DerivArray $DerivativeArray1 -BooleanArray $script:InvalidDerivs1
        $script:InvalidDerivs2 = Verify-Derivatives -DerivArray $DerivativeArray2 -BooleanArray $script:InvalidDerivs2
        $script:InvalidDerivs3 = Verify-Derivatives -DerivArray $DerivativeArray3 -BooleanArray $script:InvalidDerivs3


        # Metric Shit Ton of Arrays for Less Repetition (Messages, Base Folders, Derivative Folders, Base Booleans, Derivative Booleans)
        $BaseMessages          = @('   Far Cry 2     ','   Sandbox       ','   Tools         ')
        $BaseDirectories       = @($script:FarCry2Folder, $script:SandboxFolder, $script:ToolsFolder)
        $BaseBoolArray         = @($InvalidDirectory1, $InvalidDirectory2, $InvalidDirectory3)

        $DerivativeArrArr      = @( @($DerivativeArray1), @($DerivativeArray2), @($DerivativeArray3) )
        $DerivBoolArrArr       = @( @($script:InvalidDerivs1), @($script:InvalidDerivs2), @($script:InvalidDerivs3) )


        # Output Directory Listing
        Write-Host "`n`n Directory Info:" -ForegroundColor Yellow
         
        for ($Index=0; $Index -lt $BaseMessages.Count; $Index++) {

            Write-Host $BaseMessages[$Index] -NoNewLine ; Write-Host "  | " -NoNewline -ForegroundColor Yellow

            if ($BaseBoolArray[$Index]) { Write-Host $BaseDirectories[$Index] -ForegroundColor Red }
            elseif ($DerivBoolArrArr[$Index] -contains $TRUE) { Write-Host $BaseDirectories[$Index] -NoNewline ; Write-Host "*" -ForegroundColor Red }
            else { $BaseDirectories[$Index] }

            if ($FunctionCheck) { Display-Derivatives -BaseItem $BaseDirectories[$Index] -DerivArray $DerivativeArrArr[$Index] }
        }
    }
    function List-MenuOption ([string]$Command,[string]$Message,[array]$Dependencies) {

        $Spacing = " " * (7 - $Command.Length)

        Write-Host "   [" -NoNewline
        Write-Host "$Command$Spacing" -ForegroundColor Red -NoNewline
        Write-Host "]       " -NoNewline
 
        foreach ($Dependency in $Dependencies) {
            if ($Dependency -eq $TRUE) { $MissingDependency = $TRUE }
        }

        if ($MissingDependency) { Write-Host $Message -ForegroundColor Red }
        else { Write-Host $Message }
    }
    function Generic-Error {
        Write-Host "`n   Invalid input." -ForegroundColor Red ; Start-Sleep -Seconds 1
    }


    # Script Options
    function Start-GameInstance {
    
        # Directoy Validation
        if ($script:InvalidDerivs1[0]) {
            Write-Host "`n   Missing 'FarCry2.exe' executable! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
            break
        }


        # Visual Formatting
        Clear-Host
        Banner

        Write-Host "`n`n Function List:" -ForegroundColor Yellow
        List-MenuOption -Command "start"


        # Launch Game
        Write-Host "`n`n   [LAUNCHING]" -ForegroundColor Green
        . $script:FarCry2exe
        Start-Sleep -Seconds 5
    }
    function Unpack-GameFiles {
   
        # Directoy Validation
        if ($script:InvalidDerivs1[1]) {
            Write-Host "`n   Missing '\Data_Win32' directory! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
            break
        }
        elseif ($script:InvalidDerivs2[0]) {
            Write-Host "`n   Sandbox not initialized! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
            break
        }
        elseif ($script:InvalidDerivs3[1]) {
            Write-Host "`n   Missing 'Gibbed.Dunia.Unpack.exe' executable! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
            break
        }
         

        # Visual Formatting
        Clear-Host
        Banner
        
        Write-Host "`n`n Function List:" -ForegroundColor Yellow
        List-MenuOption -Command "unpack"
        

        # Find all '.dat' Files to Unpack
        Get-ChildItem -LiteralPath $script:FarCry2Win32 -Recurse -Name "*.dat" | % { $DatFiles += @($_) }

        try {

            # Unpack Game Files
            Write-Host "`n`n   [UNPACKING...]" -ForegroundColor Yellow

            foreach ($DatFile in $DatFiles) {

                $BaseName    = ($DatFile).Split('\')[-1]
                $DatFullName = "$script:FarCry2Win32\$DatFile"
                . $script:UnpackExe $DatFullName

                Write-Host "   - " -NoNewline -ForegroundColor Yellow
                if (Test-Path -LiteralPath $DatFullName.Replace('.dat','_unpack')) {
                    $BaseName.ToUpper()
                }
                else { Write-Host $BaseName.ToUpper() -ForegroundColor Red }
            }
            Start-Sleep -Seconds 2


            # Convert Language '.rml' Files to Readable '.xml' Format
            Write-Host "`n   [CONVERTING...]" -ForegroundColor Yellow
            
            foreach ($LanguageDir in (Get-ChildItem -LiteralPath $script:FarCry2Win32 -Recurse -Directory 'languages').FullName) {

                Get-ChildItem -LiteralPath $LanguageDir -Recurse -Name '*.rml' | % { 
                    
                    $LangFilePath = "$LanguageDir\$_"
                    . $script:XmlExe "$LangFilePath"
                    Remove-Item -LiteralPath "$LangFilePath" -Force
                    Start-Sleep -Milliseconds 125

                    Write-Host "   - " -NoNewline -ForegroundColor Yellow
                    if (Test-Path -LiteralPath $LangFilePath.Replace('.rml','_converted.xml')) {
                         $LangFilePath.Replace("$script:FarCry2Win32","").ToUpper()
                    }
                    else { Write-Host $LangFilePath.Replace("$script:FarCry2Win32","").ToUpper() -ForegroundColor Red }
                }
            }
            Start-Sleep -Seconds 2


            # Unpack 'entitylibrary.fcb' and 'entitylibrarypatchoverride.fcb' Archives
            $FcbFiles = $NULL

            Get-ChildItem -LiteralPath $script:FarCry2Win32 -Recurse -Filter 'entitylibrary.fcb' | % { $FcbFiles += @($_.FullName) }
            Get-ChildItem -LiteralPath $script:FarCry2Win32 -Recurse -Filter 'entitylibrarypatchoverride.fcb' | % { $FcbFiles += @($_.FullName) }

            foreach ($FcbFile in $FcbFiles) {
                    
                . $script:BinaryExe $FcbFile | Out-Null
                Remove-Item -LiteralPath $FcbFile -Force
                Write-Host "   - " -NoNewline -ForegroundColor Yellow ; $FcbFile.Replace("$script:FarCry2Win32","").ToUpper()
            }
            Start-Sleep -Seconds 2
            

            # Move Game Files to Unpacked Directory
            Write-Host "`n   [MOVING...]" -ForegroundColor Yellow

            foreach ($DatFile in $DatFiles) {
                
                $UnpackName = (($DatFile).Split('\')[-1]).Replace('.dat','_unpack')
                $InputName  = "$script:FarCry2Win32\" + $DatFile.Replace('.dat','_unpack')
                $OutputName = "$script:UnpackOutput\$UnpackName"


                if ($UnpackName -eq 'PATCH_UNPACK') { Move-Item -LiteralPath $InputName "$script:SandboxFolder\$UnpackName" -Force -ErrorAction SilentlyContinue }
                else { Move-Item -LiteralPath $InputName $OutputName -Force -ErrorAction SilentlyContinue }

                Write-Host "   - " -NoNewline -ForegroundColor Yellow ;
                if (Test-Path -LiteralPath $OutputName) {
                    $UnpackName.ToUpper()
                }
                else { Write-Host $UnpackName.ToUpper() }
            }
            Start-Sleep -Seconds 2


            Write-Host "`n   [DONE]" -ForegroundColor Green
            Start-Sleep -Seconds 3
        }

        # Error Correction if Files Didn't Output Correctly
        catch {

            Write-Host "`n   File(s) not found! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
        }
    }
    function Pack-GameFiles {
    
        # Directoy Validation
        if ($script:InvalidDerivs1[1]) {
            Write-Host "`n   Missing '\Data_Win32' directory! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
            break
        }
        elseif ($script:InvalidDerivs2[4]) {
            Write-Host "`n   Missing '\patch_unpack' directory! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
            break
        }
        elseif ($script:InvalidDerivs3[0]) {
            Write-Host "`n   Missing 'Gibbed.Dunia.Pack.exe' executable! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
            break
        }


        # Visual Formatting
        Clear-Host
        Banner
        
        Write-Host "`n`n Function List:" -ForegroundColor Yellow
        List-MenuOption -Command "pack"

        try {
    
            # Packed Input / Output
            $PatchDatIn = $script:PatchUnpack + ".dat"
            $PatchFatIn = $script:PatchUnpack + ".fat"
            $PatchDatOut = "$script:FarCry2Win32\patch.dat"
            $PatchFatOut = "$script:FarCry2Win32\patch.fat"


            # Convert '.xml' Files back to '.rml' Format
            Write-Host "`n`n   [CONVERTING...]" -ForegroundColor Yellow

            foreach ($XmlFile in (Get-ChildItem -LiteralPath "$script:PatchUnpack\languages" -Recurse -Name '*.xml')) {
                   
                $InputXml =  "$script:PatchUnpack\languages\$XmlFile"
                $OutputRml = $InputXml.Replace('_converted.xml','.rml')

                . $script:XmlExe $InputXml $OutputRml
                Remove-Item -LiteralPath "$InputXml" -Force
                Write-Host "   - " -NoNewline -ForegroundColor Yellow ; $XmlFile.ToUpper()
            }
            Start-Sleep -Seconds 2

            # Convert 'entitylibrary.xml'/'entitylibrarypatchoverride.xml' Archives back to '.fcb' Format
            foreach ($FcbArchiveXml in (Get-ChildItem -LiteralPath $script:PatchUnpack -Recurse -Filter 'entitylibrary*.xml')) {

                . $script:BinaryExe $FcbArchiveXml.FullName | Out-Null
                Remove-Item -LiteralPath $FcbArchiveXml.FullName -Force
                Remove-Item -LiteralPath ($FcbArchiveXml.FullName).Replace(".xml","") -Force -Recurse
                Write-Host "   - " -NoNewline -ForegroundColor Yellow ; ($FcbArchiveXml.FullName).Replace("$script:PatchUnpack","").ToUpper()
            }
            Start-Sleep -Seconds 2


            # Pack Game Files
            Write-Host "`n   [PACKING...]" -ForegroundColor Yellow
            . $script:PackExe $script:PatchUnpack
            Write-Host "   - " -NoNewline -ForegroundColor Yellow ; 'PATCH_UNPACK'
            Start-Sleep -Seconds 2


            # Move Game Files to FC2's '.\Data_Win32' directory
            Write-Host "`n   [MOVING...]" -ForegroundColor Yellow
            Move-Item -LiteralPath "$PatchDatIn" "$PatchDatOut" -Force -ErrorAction Stop
            Write-Host "   - " -NoNewline -ForegroundColor Yellow ; 'PATCH.DAT'
            Move-Item -LiteralPath "$PatchFatIn" "$PatchFatOut" -Force -ErrorAction Stop
            Write-Host "   - " -NoNewline -ForegroundColor Yellow ; 'PATCH.FAT'
            Start-Sleep -Seconds 2


            ## UNDO ##

            # Convert Language '.rml' Files back to '.xml'
            foreach ($RmlFile in (Get-ChildItem -LiteralPath "$script:PatchUnpack\languages" -Recurse -Name '*.rml')) {
                    
                . $script:XmlExe "$script:PatchUnpack\languages\$RmlFile"
                Remove-Item -LiteralPath "$script:PatchUnpack\languages\$RmlFile" -Force
            }

            # Convert 'entitylibrary.fcb' and 'entitylibrarypatchoverride.fcb' Archives
            foreach ($FcbFile in (Get-ChildItem -LiteralPath $script:PatchUnpack -Recurse -Filter 'entitylibrary*.fcb').FullName) {
                    
                . $script:BinaryExe $FcbFile | Out-Null
                Remove-Item -LiteralPath $FcbFile -Force
            }

            Write-Host "`n   [DONE]" -ForegroundColor Green
            Start-Sleep -Seconds 3
        }


        # Error Correction if Files Didn't Output Correctly
        catch {
            Write-Host "`n   File(s) not found! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
        }
    }
    function Texture-Conversion {

        # Internal Conversion Functions    
        function XBT-to-DDS {
            
            # Create Array of .xbt Files
            Get-ChildItem -LiteralPath $script:XbtTextures -Name "*.xbt" | % { $XbtFiles += @($_) }

            if ($XbtFiles.Count -eq 0) {
                Write-Host "`n   No '.xbt' files found! Aborting." -ForegroundColor Red
                Start-Sleep -Seconds 2
                break 
            }
            elseif ($script:InvalidDerivs3[5]) {
                Write-Host "`n   No 'FC2.xbt2dds.exe' executable! Aborting." -ForegroundColor Red
                Start-Sleep -Seconds 2
                break 
            }


            # Visual Formatting
            Clear-Host
            Banner
            
            Write-Host "`n`n Function List:" -ForegroundColor Yellow
            List-MenuOption -Command "convert"

            Write-Host "`n`n Select Conversion:" -ForegroundColor Yellow
            List-MenuOption -Command "one"

            Write-Host "`n`n   [CONVERTING TO DDS...]" -ForegroundColor Yellow

            foreach ($XbtFile in $XbtFiles) { 
                
                $SchteveFile = $XbtFile.Replace('.xbt','.schteve')
                $DdsFile     = $XbtFile.Replace('.xbt','.dds')
                $XbtFilePath = "$script:XbtTextures\$XbtFile"
                $SchteveOutput = "$script:DdsTextures\" + $SchteveFile

                # Output .xbt Header to .schteve File (ADDED CORE SUPPORT)
                if ($PSEdition -eq 'Core') { $FileBytes   = (Get-Content -LiteralPath $XbtFilePath -AsByteStream -First 50) -Join ' ' }
                else { $FileBytes   = (Get-Content -LiteralPath $XbtFilePath -Encoding Byte -First 50) -Join ' ' }

                $XbtHeader   = ($FileBytes -Split ' 68 68 83')[0] -Split ' '
                [System.IO.File]::WriteAllBytes($SchteveOutput,$XbtHeader)
                
                # Convert .xbt Files to .dds Files
                . $script:ConverterExe -io $XbtFilePath $script:DdsTextures | Out-Null
                Write-Host "   - " -NoNewline -ForegroundColor Yellow ; $DdsFile.ToUpper()
                Write-Host "   - " -NoNewline -ForegroundColor Yellow ; $SchteveFile.ToUpper()
            }
            Start-Sleep -Seconds 2

            Write-host "`n   [DONE]" -ForegroundColor Green
            Start-Sleep -Seconds 3
        }
        function DDS-to-XBT {
            
            # Create Arrays of .xbt and .schteve Files
            Get-ChildItem -LiteralPath $script:DdsTextures -Name "*.dds" | % { $DdsFiles += @($_) }

            if ($DdsFiles.Count -eq 0) {
                Write-Host "`n   No '.dds' files found! Aborting." -ForegroundColor Red
                Start-Sleep -Seconds 2
                break 
            }


            # Visual Formatting
            Clear-Host
            Banner

            Write-Host "`n`n Function List:" -ForegroundColor Yellow
            List-MenuOption -Command "convert"

            Write-Host "`n`n Select Conversion:" -ForegroundColor Yellow
            List-MenuOption -Command "two"
      
            Write-Host "`n`n   [CONVERTING TO XBT...]" -ForegroundColor Yellow

            for ($Index = 0; $Index -lt $DdsFiles.Count; $Index++) {
            
                $DdsFile         = $DdsFiles[$Index]
                $XbtFile         = $DdsFile.Replace('.dds','.xbt')
                $XbtOutput       = "$script:XbtTextures\" + $XbtFile
                $DdsFilePath     = "$script:DdsTextures\" + $DdsFile
                $SchteveFilePath = $DdsFilePath.Replace('.dds','.schteve')


                # Concatenate Header Bytes with .dds File Bytes; Output .xbt File
                try {
                
                    $FileHead    = [System.IO.File]::ReadAllBytes($SchteveFilePath)
                    $FileBase    = [System.IO.File]::ReadAllBytes($DdsFilePath)
                    $FileContent = $FileHead + $FileBase

                    # Output Recreated .xbt File
                    [System.IO.File]::WriteAllBytes($XbtOutput,$FileContent)
                    Write-Host "   - " -NoNewline -ForegroundColor Yellow ; $XbtFile.ToUpper()
                }
                catch {
                    Write-Host "   - " -NoNewline -ForegroundColor Yellow ; Write-Host $XbtFile.ToUpper() -ForegroundColor Red
                }
            }
            Start-Sleep -Seconds 2

            Write-host "`n   [DONE]" -ForegroundColor Green
            Start-Sleep -Seconds 3
        }


        # Directory Validation
        if ($script:InvalidDerivs2[1] -or $script:InvalidDerivs2[2]) {
            Write-Host "`n   Sandbox not initialized! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
            break
        }


        $MiniMenu = $TRUE
        while ($MiniMenu) {
        
            Clear-Host
            Banner

            Write-Host "`n`n Function List:" -ForegroundColor Yellow
            List-MenuOption -Command "convert"

            Write-Host "`n`n Select Conversion:" -ForegroundColor Yellow
            List-MenuOption -Command "one" -Message "XBT-to-DDS"
            List-MenuOption -Command "two" -Message "DDS-to-XBT"
            List-MenuOption -Command "back" -Message "Back to Main Menu"

            # User Input
            Write-Host "`n`n Selection:`n   |" -NoNewline -ForegroundColor Yellow; $ConversionInput = Read-Host
        
            switch ( $ConversionInput.ToUpper() ) {
                default { Generic-Error }
                "ONE"   { XBT-to-DDS    }
                "TWO"   { DDS-to-XBT    }
                "BACK"  { $MiniMenu = $FALSE }
                "EXIT"  { $MiniMenu = $FALSE ; $script:MainMenu = $FALSE }
            }
        }
    }
    function XML-Decoding {
        
        # Directoy Validation
        if ($script:InvalidDerivs2[3]) {
            Write-Host "`n   Sandbox not initialized! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
            break
        }
        elseif ($script:InvalidDerivs3[4]) {
            Write-Host "`n   Missing 'Wob.FC2Dunia.exe' executable! Aborting." -ForegroundColor Red
            Start-Sleep -Seconds 2
            break
        }
        

        # Visual Formatting
        Clear-Host
        Banner

        Write-Host "`n`n Function List:" -ForegroundColor Yellow
        List-MenuOption -Command "decode"

        
        # Visual Formatting for Consistency
        Get-ChildItem -LiteralPath $script:XmlDecoding -Name "*.xml" | % { $XmlFiles += @($_) }
        Write-Host "`n`n   [DECODING...]" -ForegroundColor Yellow


        # Only Line doing Actual Decoding
        . $script:DecoderExe -n -t $script:XmlDecoding | Out-Null


        # Comparing LastWriteTime to Completion time for Success Estimate
        $CompletionTime = (Get-Date).AddSeconds(-30)

        foreach ($XmlFile in $XmlFiles) {
            
            $LastWrite = (Get-Item -LiteralPath "$script:XmlDecoding\$XmlFile").LastWriteTime
            if ($CompletionTime -lt $LastWrite) { Write-Host "   - " -NoNewline -ForegroundColor Yellow ; $XmlFile.ToUpper() }
            else { Write-Host "   - " -NoNewline -ForegroundColor Yellow ; Write-Host $XmlFile.ToUpper() -ForegroundColor Red }
        }
        Start-Sleep -Seconds 2

        Write-host "`n   [DONE]" -ForegroundColor Green
        Start-Sleep -Seconds 3
    }
    function Folder-Options {
        
        # Internal Options Functions
        function Modify-Folders {
            
            function Missing-Directory {
                Write-Host "`n Directory does not exist." -ForegroundColor Red
                Start-Sleep -Seconds 1
            }
            
            # Set all initial variables to $NULL
            $tempFarCry2Folder = $NULL
            $tempSandboxFolder = $NULL
            $tempToolsFolder   = $NULL
            $SaveConfig        = $NULL


            while ($TRUE) {
                
                # Visual Formatting
                Clear-Host
                Banner -FunctionCheck

                Write-Host "`n Function List:" -ForegroundColor Yellow
                List-MenuOption -Command "options"
                Write-Host "`n`n Select Option:" -ForegroundColor Yellow
                List-MenuOption -Command "modify"


                # Convoluted Logic to Allow for 'back' Functionality
                if ($tempFarCry2Folder) {
                    Write-Host "`n`n 'Far Cry 2' Directory:`n   |" -NoNewline -ForegroundColor Yellow ; $tempFarCry2Folder
                }
                if ($tempSandboxFolder) {
                    Write-Host "`n 'Sandbox' Directory:`n   |" -NoNewline -ForegroundColor Yellow ; $tempSandboxFolder
                }
                if ($tempToolsFolder) {
                    Write-Host "`n 'Tools' Directory:`n   |" -NoNewline -ForegroundColor Yellow ; $tempToolsFolder
                    Write-Host "`n Save current folder configuration? (yes/no)`n   |" -NoNewLine -ForegroundColor Yellow
                }

                # Save settings and exit
                if (($SaveConfig -eq "yes") -or ($SaveConfig -eq "y")) { $SaveConfig ; break }
                elseif (($SaveConfig -eq "no") -or ($SaveConfig -eq "n")) {

                    $tempFarCry2Folder = $NULL
                    $tempSandboxFolder = $NULL
                    $tempToolsFolder   = $NULL
                    $SaveConfig        = $NULL
                    continue
                }
                # End Convoluted Logic
                
                # User Input
                if (!$tempFarCry2Folder) {
                    
                    Write-Host "`n`n 'Far Cry 2' Directory:`n   |" -NoNewline -ForegroundColor Yellow ; $tempFarCry2Folder = Read-Host

                    if ($tempFarCry2Folder -eq 'EXIT') { $script:MiniMenu = $FALSE ; $script:MainMenu = $FALSE ; return }
                    elseif ($tempFarCry2Folder -eq 'BACK') { return }
                    elseif ( !(Test-Path -LiteralPath $tempFarCry2Folder) ) { Missing-Directory ; $tempFarCry2Folder = $NULL }
                    else {
                        # Remove Trailing '/' or '\'
                        while (($tempFarCry2Folder[-1] -eq '/') -or ($tempFarCry2Folder[-1] -eq '\')) {
                            $tempFarCry2Folder = $tempFarCry2Folder.Substring(0, $tempFarCry2Folder.Length-1)
                        }
                        continue
                    }
                }
                elseif (!$tempSandboxFolder) {
                    
                    Write-Host "`n 'Sandbox' Directory:`n   |" -NoNewline -ForegroundColor Yellow ; $tempSandboxFolder = Read-Host

                    if ($tempSandboxFolder -eq 'EXIT') { $script:MiniMenu = $FALSE ; $script:MainMenu = $FALSE ; return }
                    elseif ($tempSandboxFolder -eq 'BACK') { 
                        $tempFarCry2Folder = $NULL
                        $tempSandboxFolder = $NULL
                        continue
                    }
                    elseif ( !(Test-Path -LiteralPath $tempSandboxFolder) ) { Missing-Directory ; $tempSandboxFolder = $NULL }
                    else {
                        # Remove Trailing '/' or '\'
                        while (($tempSandboxFolder[-1] -eq '/') -or ($tempSandboxFolder[-1] -eq '\')) {
                            $tempSandboxFolder = $tempSandboxFolder.Substring(0, $tempSandboxFolder.Length-1)
                        }
                        continue
                    }
                }
                elseif (!$tempToolsFolder) {
                    
                    Write-Host "`n 'Tools' Directory:`n   |" -NoNewline -ForegroundColor Yellow ; $tempToolsFolder   = Read-Host

                    if ($tempToolsFolder -eq 'EXIT') { $script:MiniMenu = $FALSE ; $script:MainMenu = $FALSE ; return }
                    elseif ($tempToolsFolder -eq 'BACK') {
                        $tempSandboxFolder = $NULL
                        $tempToolsFolder   = $NULL
                        continue
                    }
                    elseif ( !(Test-Path -LiteralPath $tempToolsFolder) ) { Missing-Directory ; $tempToolsFolder = $NULL }
                    else {
                        # Remove Trailing '/' or '\'
                        while (($tempToolsFolder[-1] -eq '/') -or ($tempToolsFolder[-1] -eq '\')) {
                            $tempToolsFolder = $tempToolsFolder.Substring(0, $tempToolsFolder.Length-1)
                        }
                        continue
                    }
                }
                elseif (!$SaveConfig) {

                    $SaveConfig = Read-Host

                    if (($SaveConfig -eq "yes") -or ($SaveConfig -eq "y") -or ($SaveConfig -eq "no") -or ($SaveConfig -eq "n")) { continue }
                    elseif ($SaveConfig -eq "EXIT") { $script:MiniMenu = $FALSE ; $script:MainMenu = $FALSE ; return }
                    elseif ($SaveConfig -eq "BACK") {
                        $tempToolsFolder = $NULL
                        $SaveConfig      = $NULL
                        continue
                    }
                    else { Generic-Error ; $SaveConfig = $NULL }
                }
            }


            # Modify Directory Values and Replace Script (Set-Content used for Proper .ps1 Encoding)
            $SchteveFilename = $MyInvocation.PSCommandPath
            $BaseFile = Get-Content -Literalpath $SchteveFilename

            [string]$FC2Line      = ($BaseFile | Select-String "<#RegexTag1#>")[0]
            [string]$SandboxLine  = ($BaseFile | Select-String "<#RegexTag2#>")[0]
            [string]$ToolsLine    = ($BaseFile | Select-String "<#RegexTag3#>")[0]

            $FixedFC2Line         = $FC2Line.Replace($script:FarCry2Folder,$tempFarCry2Folder)
            $FixedSandboxLine     = $SandboxLine.Replace($script:SandboxFolder,$tempSandboxFolder)
            $FixedToolsLine       = $ToolsLine.Replace($script:ToolsFolder,$tempToolsFolder)

            $FinalContent         = $BaseFile.Replace($FC2Line,$FixedFC2Line).Replace($SandboxLine,$FixedSandboxLine).Replace($ToolsLine,$FixedToolsLine)


            # (ADDED CORE SUPPORT)
            if ($PSEdition -eq 'Core') { Set-Content -Encoding UTF8BOM -LiteralPath $SchteveFilename -Value $FinalContent }
            else { Set-Content -Encoding UTF8 -LiteralPath $SchteveFilename -Value $FinalContent }


            # Replace Directory Variables so Reloading isn't Required
            $script:FarCry2Folder = $tempFarCry2Folder
            $script:SandboxFolder = $tempSandboxFolder
            $script:ToolsFolder   = $tempToolsFolder


            # Recreate Derivative Variables
            $script:FarCry2exe    = "$script:FarCry2Folder\bin\FarCry2.exe"
            $script:FarCry2Win32  = "$script:FarCry2Folder\Data_Win32"

            $script:UnpackOutput  = "$script:SandboxFolder\[] Raw Files"
            $script:XbtTextures   = "$script:SandboxFolder\[] Texture Conversion\XBT"
            $script:DdsTextures   = "$script:SandboxFolder\[] Texture Conversion\DDS"
            $script:XmlDecoding   = "$script:SandboxFolder\[] XML Decoding"
            $script:PatchUnpack   = "$script:SandboxFolder\patch_unpack"

            $script:PackExe       = "$script:ToolsFolder\Gibbed.Dunia\Gibbed.Dunia.Pack.exe"
            $script:UnpackExe     = "$script:ToolsFolder\Gibbed.Dunia\Gibbed.Dunia.Unpack.exe"
            $script:XmlExe        = "$script:ToolsFolder\Gibbed.Dunia\Gibbed.Dunia.ConvertXml.exe"
            $script:BinaryExe     = "$script:ToolsFolder\Gibbed.Dunia\Gibbed.Dunia.ConvertBinary.exe"
            $script:ConverterExe  = "$script:ToolsFolder\Texture Converter\FC2.xbt2dds.exe"
            $script:DecoderExe    = "$script:ToolsFolder\XML Decoder System Files\Wob.FC2Dunia.exe"

            Write-Host "`n   [DONE]" -ForegroundColor Green
            Start-Sleep -Seconds 3
        }
        function Create-Folders {
            
            # Directory Validation
            if ( !($script:InvalidDerivs2[0]) -and !($script:InvalidDerivs2[1]) -and !($script:InvalidDerivs2[2]) -and !($script:InvalidDerivs2[3]) ) { 
                Write-Host "`n   All sandbox directories found! Aborting." -ForegroundColor Red
                Start-Sleep -Seconds 2
                break
            }


            # Visual Formatting
            Clear-Host
            Banner -FunctionCheck

            Write-Host "`n Function List:" -ForegroundColor Yellow
            List-MenuOption -Command "options"

            Write-Host "`n`n Select Option:" -ForegroundColor Yellow
            List-MenuOption -Command "init"


            # Creating Sandbox Directories
            Write-Host "`n`n   [CREATING FOLDERS...]" -ForegroundColor Yellow

            
            $script:UnpackOutput   = "$script:SandboxFolder\[] Raw Files"
            $script:XbtTextures    = "$script:SandboxFolder\[] Texture Conversion\XBT"
            $script:DdsTextures    = "$script:SandboxFolder\[] Texture Conversion\DDS"
            $script:XmlDecoding    = "$script:SandboxFolder\[] XML Decoding"
            $script:PatchUnpack    = "$script:SandboxFolder\patch_unpack"


            if ($script:InvalidDerivs2[0]) { 
                New-Item -ItemType Directory $script:UnpackOutput -Force | Out-Null
                Write-Host "   - " -NoNewline -ForegroundColor Yellow ; ("[] Raw Files").ToUpper()
            }
            else { Write-Host "   - " -NoNewline -ForegroundColor Yellow ; Write-Host ("[] Raw Files").ToUpper() -ForegroundColor Red }


            if ($script:InvalidDerivs2[1]) {
                New-Item -ItemType Directory $script:XbtTextures -Force | Out-Null
                Write-Host "   - " -NoNewline -ForegroundColor Yellow ; ("[] Texture Conversion\XBT").ToUpper()
             }
             else { Write-Host "   - " -NoNewline -ForegroundColor Yellow ; Write-Host ("[] Texture Conversion\XBT").ToUpper() -ForegroundColor Red }


            if ($script:InvalidDerivs2[2]) {
                New-Item -ItemType Directory $script:DdsTextures -Force | Out-Null
                Write-Host "   - " -NoNewline -ForegroundColor Yellow ; ("[] Texture Conversion\DDS").ToUpper()
            }
            else { Write-Host "   - " -NoNewline -ForegroundColor Yellow ; Write-Host ("[] Texture Conversion\DDS").ToUpper() -ForegroundColor Red }


            if ($script:InvalidDerivs2[3]) {
                New-Item -ItemType Directory $script:XmlDecoding -Force | Out-Null
                Write-Host "   - " -NoNewline -ForegroundColor Yellow ; ("[] XML Decoding").ToUpper()
            }
            else { Write-Host "   - " -NoNewline -ForegroundColor Yellow ; Write-Host ("[] XML Decoding").ToUpper() -ForegroundColor Red }
            Start-Sleep -Seconds 2


            Write-Host "`n   [DONE]" -ForegroundColor Green
            Start-Sleep -Seconds 3
        }


        $script:MiniMenu = $TRUE
        while ($script:MiniMenu) {
        
            Clear-Host
            Banner -FunctionCheck

            Write-Host "`n Function List:" -ForegroundColor Yellow
            List-MenuOption -Command "options"

            Write-Host "`n`n Select Option:" -ForegroundColor Yellow
            List-MenuOption -Command "modify" -Message "Modify Main Directories"
            List-MenuOption -Command "init" -Message "Initialize Sandbox"
            List-MenuOption -Command "back" -Message "Back to Main Menu"

            # User Choice
            Write-Host "`n`n Selection:`n   |" -NoNewline -ForegroundColor Yellow; $ConversionInput = Read-Host
        
            switch ( $ConversionInput.ToUpper() ) {
                default  { Generic-Error  }
                "MODIFY" { Modify-Folders }
                "INIT"   { Create-Folders }
                "BACK"   { $script:MiniMenu = $FALSE }
                "EXIT"   { $script:MiniMenu = $FALSE ; $script:MainMenu = $FALSE }
            } 
        }
    }
    function Display-Help {

        Clear-Host
        Get-Help Schteve

        Write-Host "`n`n Press any key to return to the main menu." -ForegroundColor Yellow
        $NULL = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
    }


    # Main Menu System
    $script:MainMenu = $TRUE

    while ($script:MainMenu) {

        Clear-Host
        Banner

        # Function List
        Write-Host "`n`n Function List:" -ForegroundColor Yellow

        List-MenuOption -Command "start"   -Message "Launch Far Cry® 2."                                      -Dependencies @($script:InvalidDerivs1[0])
        List-MenuOption -Command "unpack"  -Message "Unpack all game instance '.dat'/'.fat' files."           -Dependencies @($script:InvalidDerivs1[0],$script:InvalidDerivs2[0],$script:InvalidDerivs3[1])
        List-MenuOption -Command "pack"    -Message "Pack 'patch_unpack' and move files into game directory." -Dependencies @($script:InvalidDerivs1[1],$script:InvalidDerivs2[4],$script:InvalidDerivs3[0])
        List-MenuOption -Command "convert" -Message "Convert '.xbt' <--> '.dds' texture files."               -Dependencies @($script:InvalidDerivs2[1],$script:InvalidDerivs2[2],$script:InvalidDerivs3[5])
        List-MenuOption -Command "decode"  -Message "Decode entitylibrarypatchoverride '.xml' files."         -Dependencies @($script:InvalidDerivs2[3],$script:InvalidDerivs3[4])
        List-MenuOption -Command "options" -Message "View or edit directory information."
        List-MenuOption -Command "help"    -Message "Display Get-Help page."
        List-MenuOption -Command "exit"    -Message "Exit SCHTEVE."
        
        # User Input
        Write-Host "`n`n Selection:`n   |" -NoNewline -ForegroundColor Yellow ; $MenuInput = Read-host

        switch ( $MenuInput.ToUpper() ) {   
            default   { Generic-Error      }
            "START"   { Start-GameInstance }
            "UNPACK"  { Unpack-GameFiles   }
            "PACK"    { Pack-GameFiles     }
            "CONVERT" { Texture-Conversion }
            "DECODE"  { XML-Decoding       }
            "OPTIONS" { Folder-Options     }
            "HELP"    { Display-Help       }
            "EXIT"    { $script:MainMenu = $FALSE }
        }
    }

    # Return Original Window Settings
    $Host.UI.RawUI.WindowTitle     = $OriginalWindow
    $Host.UI.RawUI.BackgroundColor = $OriginalColor

    Clear-Host
}

Schteve